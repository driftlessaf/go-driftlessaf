/*
Copyright 2026 Chainguard, Inc.
SPDX-License-Identifier: Apache-2.0
*/

package main

import (
	"errors"
	"fmt"
	"strings"
	"text/template"

	"chainguard.dev/driftlessaf/agents/metaagent"
	"chainguard.dev/driftlessaf/reconcilers/githubreconciler/changemanager"
	"chainguard.dev/driftlessaf/reconcilers/githubreconciler/clonemanager"
	"chainguard.dev/driftlessaf/reconcilers/githubreconciler/metareconciler"
	"github.com/google/go-github/v75/github"
)

const (
	prTitleTemplate = `fix: implement issue #{{.IssueNumber}}`
	prBodyTemplate  = `Resolves {{.IssueURL}}

---
*Generated by {{.Identity}}*`
)

// reconciler is a type alias for the composed metareconciler
type reconciler[CB any] = metareconciler.Reconciler[*Request, *Result, CB]

// newReconciler constructs a reconciler from configuration.
func newReconciler[CB any](
	identity string,
	mat metaagent.Agent[*Request, *Result, CB],
	cloneMeta *clonemanager.Meta,
	prLabels []string,
	buildCallbacks metareconciler.CallbacksBuilder[CB, metareconciler.PRData],
) (*reconciler[CB], error) {
	identity = strings.TrimSpace(identity)
	if identity == "" {
		return nil, errors.New("identity must be provided")
	}
	if mat == nil {
		return nil, errors.New("materializer must be provided")
	}
	if cloneMeta == nil {
		return nil, errors.New("cloneMeta must be provided")
	}

	titleTmpl, err := template.New("title").Parse(prTitleTemplate)
	if err != nil {
		return nil, fmt.Errorf("parse title template: %w", err)
	}
	bodyTmpl, err := template.New("body").Parse(prBodyTemplate)
	if err != nil {
		return nil, fmt.Errorf("parse body template: %w", err)
	}

	cm, err := changemanager.New[metareconciler.PRData](identity, titleTmpl, bodyTmpl)
	if err != nil {
		return nil, fmt.Errorf("create change manager: %w", err)
	}

	return metareconciler.New(
		identity,
		cm,
		cloneMeta,
		prLabels,
		mat,
		func(issue *github.Issue, session *changemanager.Session[metareconciler.PRData]) *Request {
			return &Request{
				Title:    issue.GetTitle(),
				Problem:  issue.GetBody(),
				Findings: session.Findings(),
			}
		},
		buildCallbacks,
		// Only process issues that have the managed label.
		// This ensures we only materialize solutions for issues that are ready.
		metareconciler.WithRequiredLabel[*Request, *Result, CB](fmt.Sprintf("%s/managed", identity)),
	), nil
}
